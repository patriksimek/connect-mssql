// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var sql;

  sql = require('mssql');

  module.exports = function(session) {
    var MSSQLStore, Store, ref;
    Store = (ref = session.Store) != null ? ref : session.session.Store;
    MSSQLStore = (function() {
      class MSSQLStore extends Store {
        /*
        Initialize MSSQLStore with the given `options`.

        @param {Object} config
        @param {Object} [options]
        */
        constructor(config, options) {
          var database, name, ref1, schema;
          super();
          if (options) {
            if (options.table) {
              ({name, schema, database} = sql.Table.parseName(options.table));
              this.table = `${(database ? `[${database}].` : "")}${(schema ? `[${schema}].` : "")}[${name}]`;
            }
            if (options.ttl) {
              this.ttl = options.ttl;
            }
            if (options.autoRemove) {
              this.autoRemove = options.autoRemove;
            }
            if (options.autoRemoveInterval) {
              this.autoRemoveInterval = options.autoRemoveInterval;
            }
            if (options.autoRemoveCallback) {
              this.autoRemoveCallback = options.autoRemoveCallback;
            }
          }
          if (((ref1 = config.options) != null ? ref1.useUTC : void 0) != null) {
            this.useUTC = config.options.useUTC;
          }
          this.connection = new sql.ConnectionPool(config);
          this.connection.on('connect', this.emit.bind(this, 'connect'));
          this.connection.on('error', this.emit.bind(this, 'error'));
          this.connection.connect().then(() => {
            if (this.autoRemove === 'interval') {
              this.destroyExpired();
              return setInterval(this.destroyExpired.bind(this), this.autoRemoveInterval);
            }
          });
        }

        _ready(callback) {
          if (this.connection.connected) {
            return callback.call(this);
          }
          if (this.connection.connecting) {
            return this.connection.once('connect', callback.bind(this));
          }
          return callback.call(this, new Error("Connection is closed."));
        }

        /*
        Attempt to fetch session by the given `sid`.

        @param {String} sid
        @callback callback
        */
        get(sid, callback) {
          return this._ready(function(err) {
            var request;
            if (err) {
              return callback(err);
            }
            request = new sql.Request(this.connection);
            request.input('sid', sid);
            return request.query(`select session from ${this.table} where sid = @sid and expires >= get${(this.useUTC ? "utc" : "")}date()`, function(err, result) {
              if (err) {
                return callback(err);
              }
              if (result.recordset.length) {
                return callback(null, JSON.parse(result.recordset[0].session));
              }
              return callback(null, null);
            });
          });
        }

        /*
        Commit the given `sess` object associated with the given `sid`.

        @param {String} sid
        @param {Object} data
        @callback callback
        */
        set(sid, data, callback) {
          return this._ready(function(err) {
            var expires, ref1, ref2, ref3, request;
            if (err) {
              return callback(err);
            }
            expires = new Date((ref1 = (ref2 = data.cookie) != null ? ref2.expires : void 0) != null ? ref1 : Date.now() + this.ttl);
            request = new sql.Request(this.connection);
            request.input('sid', sid);
            request.input('session', JSON.stringify(data));
            request.input('expires', expires);
            if ((ref3 = this.connection.config.options.tdsVersion) === '7_1' || ref3 === '7_2') {
              //Â support for sql server 2005, 2000
              return request.query(`update ${this.table} set session = @session, expires = @expires where sid = @sid;if @@rowcount = 0 begin insert into ${this.table} (sid, session, expires) values (@sid, @session, @expires) end;`, callback);
            } else {
              return request.query(`merge into ${this.table} with (holdlock) s using (values(@sid, @session)) as ns (sid, session) on (s.sid = ns.sid) when matched then update set s.session = @session, s.expires = @expires when not matched then insert (sid, session, expires) values (@sid, @session, @expires);`, callback);
            }
          });
        }

        /*
        Update expiration date of the given `sid`.

        @param {String} sid
        @param {Object} data
        @callback callback
        */
        touch(sid, data, callback) {
          return this._ready(function(err) {
            var expires, ref1, ref2, request;
            if (err) {
              return callback(err);
            }
            expires = new Date((ref1 = (ref2 = data.cookie) != null ? ref2.expires : void 0) != null ? ref1 : Date.now() + this.ttl);
            request = new sql.Request(this.connection);
            request.input('sid', sid);
            request.input('expires', expires);
            return request.query(`update ${this.table} set expires = @expires where sid = @sid`, callback);
          });
        }

        /*
        Destroy the session associated with the given `sid`.

        @param {String} sid
        @callback callback
        */
        destroy(sid, callback) {
          return this._ready(function(err) {
            var request;
            if (err) {
              return callback(err);
            }
            request = new sql.Request(this.connection);
            request.input('sid', sid);
            return request.query(`delete from ${this.table} where sid = @sid`, callback);
          });
        }

        /*
        Destroy expired sessions.
        */
        destroyExpired(callback) {
          return this._ready(function(err) {
            var base, request;
            if (err) {
              return typeof (base = callback != null ? callback : this.autoRemoveCallback) === "function" ? base(err) : void 0;
            }
            request = new sql.Request(this.connection);
            return request.query(`delete from ${this.table} where expires <= get${(this.useUTC ? "utc" : "")}date()`, callback != null ? callback : this.autoRemoveCallback);
          });
        }

        /*
        Fetch number of sessions.

        @callback callback
        */
        length(callback) {
          return this._ready(function(err) {
            var request;
            if (err) {
              return callback(err);
            }
            request = new sql.Request(this.connection);
            return request.query(`select count(sid) as length from ${this.table}`, function(err, recordset) {
              if (err) {
                return callback(err);
              }
              return callback(null, recordset[0].length);
            });
          });
        }

        /*
        Clear all sessions.

        @callback callback
        */
        clear(callback) {
          return this._ready(function(err) {
            var request;
            if (err) {
              return callback(err);
            }
            request = new sql.Request(this.connection);
            return request.query(`truncate table ${this.table}`, callback);
          });
        }

      };

      MSSQLStore.prototype.table = '[sessions]';

      MSSQLStore.prototype.ttl = 1000 * 60 * 60 * 24;

      MSSQLStore.prototype.autoRemove = 'never';

      MSSQLStore.prototype.autoRemoveInterval = 1000 * 60 * 10;

      MSSQLStore.prototype.autoRemoveCallback = void 0;

      MSSQLStore.prototype.useUTC = true;

      return MSSQLStore;

    }).call(this);
    return MSSQLStore;
  };

}).call(this);
